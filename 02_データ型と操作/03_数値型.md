# 数値型

## 目次
- データ型
- リテラル
- 型変換
- オーバーフロー演算子

## データ型

|型|説明|
|:--|:--|
|Int, Int8〜64|符号付き整数。Int は 8バイト。Int8 は 8ビット|
|UInt, UInt8〜64|符号無し整数|
|Float, Double|不動少数点数|

<small>**例.** データサイズの出力</small>
```Swift
print(MemoryLayout<Int>.size)	// 8
print(MemoryLayout<Int8>.size)	// 1
```

## リテラル

|数値|リテラル|
|:--|:--|
|10進数|1234<br>12_34<br>1.23e1 (=12.3)|
|16進数|0xFE|
|2進数|0b1000|

- 数値の間には読みやすくするために任意の場所に「\_」を入れられる。

```Swift
print(1234) 	// 1234
print(12_34)    // 1234
print(0xFF) 	// 255
print(0b101)    // 5
```

## 型変換
- Swift には「暗黙的な型変換（※1）」はない。そのため小さいデータ型から大きいデータ型に代入する場合も「明示的な型変換」をする必要がある。逆（大きいデータを小さいデータ型に代入）は Swift でも Java でも明示的な型変換になる。
- 数値型の下記のように型変換できるイニシャライザが用意されているのでそれを使う。
```Swift
Int.init(_: Double)
Int.init(_: UInit)
```

例)
<small>**例.** Double型とInt型で相互に型変換</small>
```Swift
var f: Float = 1.23
var d: Double = 12.34

let x: Double = Double(f)
let y: Float = Float(d)
```

>（※1）暗黙な型変換：小さいデータ型の値を大きいサイズのデータ型に代入する際に自動で行われる型変換。逆は暗黙的にはしないので明示的型変換が必要。<br>
int i = 100<br>
long l = i 	// ここで int → long への暗黙的な型変換が行われる。


## オーバーフロー演算子
- + や - の前に「&」つけると、オーバーフローしてもエラーにならずあふれた部分を切り捨てて演算できる。

```Swift
print(UInt8.max)    // 255 (0b11111111)
//print(UInt8.max + 1) // エラー（桁あふれ）
print(UInt8.max &+ 1)  // 0 (0b11111111 + 0b00000001 = 0b100000000 → 1バイトでカット 0b00000000)
```
